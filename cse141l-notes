specs:
9-bit instructions
256 bytes of memory (8-bit addressable), byte-wide
16 registers (8 bit wide)
can only read/write memory once per instruction
can only write to register file once per instruction
can write an additional flag bit once per intruction
can read multiple times from register file per instruction

EVERYTHING IS ROUNDED AT LSB

programs:
p1 - multiplicative inverse
input: 16-bit unsigned integer (address 8-9)
input format is: |2^15|..|2^0|
output: 16-bit fractional result (address 10-11)
output format is: |2^0|..|2^-15|

p2 - division
input: 16-bit unsigned integer numerator (address 0-1), 8-bit unsigned integer divisor (address 2)
output: 16-bit unsigned integer quotient + 8-bit unsigned quotient fraction (address 4-6)
output format is: |2^15|..|2^-8|

p3 - square root
input: 16-bit unsigned integer (address 16-17)
input format is: |2^15|..|2^0|
output: 8-bit result (address 18)
ouput format is: |2^7|..|2^0|

LD      0000 - |REG_DEST(4)|
ST      0001 - |MEM_DEST(4)|

ADD     0010 - |REG(4)|C(1)| - REG = REG + ACC
SUB     0011 - |REG(4)|C(1)| - REG = REG - ACC

SHL     0100 - |REG(4)|C(1)| - whether or not we use carry in
SHR     0101 - |REG(3)|C(1)|

MOV     1100 - |REG(4)|D(1)|
ClR     1101 - |REG(4)|
MSB     1110 - |REG(4)|
ACC     1111 - |IMM(5)|

CCC
INC

BR      1010 - |REG(4)|TYPE(1)|

0 - shift left
1 - shift right

0 - Acc to Reg
1 - Reg to Acc

true ? a : b = a

Special registers:
R_15, accumulator
R_14, branch comparison register
R_13, branch target register
R_12, carry out register
R_11, carry in register
R_10, zero register

reg_file, dat_mem, instr_rom, pretty much done
need to customize alu, pc, instruction decoder
