//program 1 - input addr 8-9, output addr 10-11
// TODO: CORNER CHECKS (0, 1, mmm is 15)

// $r2|$r3 - div
// $r0|$r1 - num
// $r6 - result setter
// $r7 - index
// $r8 - left shift amount

acc 8
ld $r2 // $r2 = div[15:8]
acc 9
ld $r3 // $r3 = div[7:0]

// set $r0 to 80
acc 8
shl $ra
shl $ra
shl $ra
shl $ra
mov $r0 // num[15:8] = 80
acc 0
mov $r1 // num[7:0] = 00

// Generate "index" index and left shift amount
// $r7 = index
// $r8 = lsa
// we want index = lsa = 15 - overall mmm

// set $r7 = $r8 = 7-m or 15-m

targ LEFTNZ
bez $r2 // check if div[15:8] == 0 (lsa between 7-0)
acc 7   // if div[15:8] > 0
mov $r7 // index = 7 (max possible val)
mov $r8 // lsa = 7 (max possible val)
mmm $r2 // get mmm from msw
sub $r7 // index = 7-m
sub $r8 // lsa = 7-m
targ LEFT_SHIFT_PREP
bez $rz

LEFTNZ:
acc 15  // if div[15:8] == 0 (lsa between 15-8)
mov $r7 // index = 15
mov $r8 // lsa = 15
mmm $r3 // get mmm from lsw
sub $r7 // index = 15-m
sub $r8 // lsa = 15-m


// left shifts $r2|$r3 until mmm of $r2 is 1
// dec left shift amount each iter
LEFT_SHIFT_PREP:
targ MAIN_LOOP
bez $r8 // dont loop if lsa = 0
LEFT_SHIFT:
shl $r3  // 2-byte carry out left shift
ccc      // 2-byte carry out left shift
shlc $r2 // 2-byte carry out left shift
dec $r8  // lsa -= 1
targ LEFT_SHIFT
bnz $r8  // keep shifting if lsa not zero

// $r2|$r3 is left shifted all the way
// $r7 contains how much we shifted

MAIN_LOOP:

// if num < div, skip over SET_BIT and go to WRITE_CHECK
get $r0             // branch $r2 > $r0 -> WRITE_CHECK
mov $rbc            // branch $r2 > $r0 -> WRITE_CHECK
targ WRITE_CHECK    // branch $r2 > $r0 -> WRITE_CHECK
bgt $r2             // branch $r2 > $r0 -> WRITE_CHECK

targ SUB_SET_BIT    // branch $r2 < $r0 -> SUB_SET_BIT
blt $r2             // branch $r2 < $r0 -> SUB_SET_BIT

get $r1             // branch $r3 > $r1 -> WRITE_CHECK
mov $rbc            // branch $r3 > $r1 -> WRITE_CHECK
targ WRITE_CHECK    // branch $r3 > $r1 -> WRITE_CHECK
bgt $r3             // branch $r3 > $r1 -> WRITE_CHECK

SUB_SET_BIT: // num >= div, so sub and set bit
get $r3  // 2-byte borrowed subtraction
sub $r1  // 2-byte borrowed subtraction
ccc      // 2-byte borrowed subtraction
get $r2  // 2-byte borrowed subtraction
subc $r0 // 2-byte borrowed subtraction
get $r7  // set bit with mod of index
set $r6  // set bit with mod of index

// want index == 8 -> then write the left half of output
WRITE_CHECK:
acc 8
mov $rbc
targ LOOP_CHECK
bne $r7 // if index != 8, go to LOOP_CHECK
// index == 8, so write $r6 to mem and clear
acc 10
st $r6
acc 0
mov $r6

LOOP_CHECK:
shr $r2  // 2-byte carry out right shift
ccc      // 2-byte carry out right shift
shrc $r3 // 2-byte carry out right shift
dec $r7  // index -= 1
targ DONE
bez $r7  // done if index == 0
targ MAIN_LOOP
bez $rz  // otherwise, jmp to MAIN_LOOP for another iter


DONE:
// TODO: PRECISION
// disgusting corner case of carry out = 0 -> get mem 10 and inc and restore

// store $r6 to mem 11
acc 11
st $r6
